package hbase.schema.api.schemas;

import hbase.schema.api.interfaces.HBaseFilterSchema;
import hbase.schema.api.interfaces.conversion.BytesConverter;
import org.apache.hadoop.hbase.filter.ColumnPrefixFilter;
import org.apache.hadoop.hbase.filter.Filter;
import org.apache.hadoop.hbase.filter.FilterList;
import org.apache.hadoop.hbase.filter.MultiRowRangeFilter;
import org.apache.hadoop.hbase.util.Bytes;
import org.jetbrains.annotations.Nullable;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.NavigableSet;
import java.util.function.Function;
import java.util.stream.Stream;

import static hbase.schema.api.utils.HBaseSchemaUtils.asBytesTreeSet;
import static hbase.schema.api.utils.HBaseSchemaUtils.chain;
import static hbase.schema.api.utils.HBaseSchemaUtils.combineNullableFilters;
import static hbase.schema.api.utils.HBaseSchemaUtils.mapArray;
import static java.util.Arrays.asList;

/**
 * Builder for {@link HBaseFilterSchema} objects, providing a fluent API to add fields and field prefixes to be fetched
 *
 * @param <T> query object type
 */
public class HBaseFilterSchemaBuilder<T> {
    private final NavigableSet<byte[]> prefixes = asBytesTreeSet();
    private Function<T, byte[]> scanKeyMapper = null;
    private Function<T, Filter> filterBuilder = obj -> null;

    /**
     * Sets the column prefixes to be filtered
     *
     * @param first first prefix
     * @param rest  other prefixes
     * @return this builder
     */
    public HBaseFilterSchemaBuilder<T> withPrefixes(byte[] first, byte[]... rest) {
        prefixes.add(first);
        prefixes.addAll(asList(rest));
        return this;
    }

    /**
     * Sets the column prefixes to be filtered
     *
     * @param first first prefix
     * @param rest  other prefixes
     * @return this builder
     */
    public HBaseFilterSchemaBuilder<T> withPrefixes(String first, String... rest) {
        return withPrefixes(
                first.getBytes(StandardCharsets.UTF_8),
                mapArray(rest, byte[].class, s -> s.getBytes(StandardCharsets.UTF_8))
        );
    }

    /**
     * Generates the scan key prefix
     *
     * @param bytesGetter generates a {@code byte[]} scan key
     * @return this builder
     */
    public HBaseFilterSchemaBuilder<T> withScanKey(Function<T, byte[]> bytesGetter) {
        this.scanKeyMapper = bytesGetter;
        return this;
    }

    /**
     * Generates the scan key prefix
     *
     * @param getter    gets the field value to generate a scan key from
     * @param converter converts the value to a proper {@code byte[]}
     * @param <U>       field type
     * @return this builder
     */
    public <U> HBaseFilterSchemaBuilder<T> withScanKey(Function<T, U> getter, Function<U, byte[]> converter) {
        return withScanKey(chain(getter, converter));
    }

    /**
     * Generates the scan key prefix
     *
     * @param getter    gets the field value to generate a scan key from
     * @param converter converts the value to a proper {@code byte[]}
     * @param <U>       field type
     * @return this builder
     */
    public <U> HBaseFilterSchemaBuilder<T> withScanKey(Function<T, U> getter, BytesConverter<U> converter) {
        return withScanKey(getter, converter::toBytes);
    }

    /**
     * Generates the scan key prefix
     *
     * @param bytesGetter generates a {@code byte[]} scan key
     * @param sliceSize   size to slice the generated byte array
     * @return this builder
     */
    public HBaseFilterSchemaBuilder<T> withScanKey(Function<T, byte[]> bytesGetter, int sliceSize) {
        return withScanKey(chain(bytesGetter, slicer(sliceSize)));
    }

    /**
     * Generates the scan key prefix
     *
     * @param getter    gets the field value to generate a scan key from
     * @param converter converts the value to a proper {@code byte[]}
     * @param sliceSize size to slice the generated byte array
     * @param <U>       field type
     * @return this builder
     */
    public <U> HBaseFilterSchemaBuilder<T> withScanKey(Function<T, U> getter,
                                                       Function<U, byte[]> converter,
                                                       int sliceSize) {
        return withScanKey(getter, chain(converter, slicer(sliceSize)));
    }

    /**
     * Generates the scan key prefix
     *
     * @param getter    gets the field value to generate a scan key from
     * @param converter converts the value to a proper {@code byte[]}
     * @param sliceSize size to slice the generated byte array
     * @param <U>       field type
     * @return this builder
     */
    public <U> HBaseFilterSchemaBuilder<T> withScanKey(Function<T, U> getter,
                                                       BytesConverter<U> converter,
                                                       int sliceSize) {
        return withScanKey(getter, chain(converter::toBytes, slicer(sliceSize)));
    }

    /**
     * Builds an ad-hoc filter based on a single query object
     *
     * @param filterBuilder builds the new filter
     * @return this builder
     */
    public HBaseFilterSchemaBuilder<T> withFilter(Function<T, Filter> filterBuilder) {
        this.filterBuilder = filterBuilder;
        return this;
    }

    /**
     * Builds a new instance of the filter schema
     *
     * @return new filter schema instance
     */
    public HBaseFilterSchema<T> build() {
        return new HBaseFilterSchema<T>() {
            @Override
            public @Nullable Filter buildColumnFilter(T query) {
                return filterColumns(query);
            }

            @Override
            public @Nullable Filter buildRowFilter(T query) {
                return filterBuilder.apply(query);
            }

            @Override
            public @Nullable Filter buildRowFilter(List<? extends T> queries) {
                Filter filter = filterScanRows(queries);
                if (filter == null) {
                    return HBaseFilterSchema.super.buildRowFilter(queries);
                } else {
                    return filter;
                }
            }
        };
    }

    /**
     * Builds a filter that selects the columns in the result output
     * <p>
     * This implementation combines {@link ColumnPrefixFilter} for all configured prefixes
     *
     * @param query query object
     * @return column filter
     */
    @Nullable
    protected Filter filterColumns(T query) {
        Stream<Filter> filters = prefixes.stream().map(ColumnPrefixFilter::new);
        return combineNullableFilters(FilterList.Operator.MUST_PASS_ONE, filters.iterator());
    }

    /**
     * Builds a filter that selects the columns in the result output
     * <p>
     * This implementation builds a {@link ColumnPrefixFilter} for all configured prefixes
     *
     * @param queries query objects
     * @return column filter
     */
    @Nullable
    protected Filter filterScanRows(Collection<? extends T> queries) {
        if (scanKeyMapper == null) {
            return null;
        }
        List<MultiRowRangeFilter.RowRange> ranges = new ArrayList<>();

        for (T query : queries) {
            byte[] scanStart = scanKeyMapper.apply(query);
            if (scanStart == null) {
                continue;
            }
            byte[] scanStop = Bytes.unsignedCopyAndIncrement(scanStart);
            ranges.add(new MultiRowRangeFilter.RowRange(
                    scanStart, true, scanStop, false
            ));
        }

        if (ranges.isEmpty()) {
            return null;
        }
        return new MultiRowRangeFilter(ranges);
    }

    private static Function<byte[], byte[]> slicer(int size) {
        return bytes -> Arrays.copyOfRange(bytes, 0, size);
    }
}
